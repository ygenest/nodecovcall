{
  "name": "spahql",
  "preferGlobal": false,
  "version": "0.7.6",
  "author": {
    "name": "Dan Glegg",
    "email": "dan@angryamoeba.co.uk"
  },
  "description": "A query language and data model for deep Javascript object structures.",
  "contributors": [
    {
      "name": "David Ellis",
      "email": "d.f.ellis@ieee.org"
    },
    {
      "name": "Andrew Cherry",
      "email": "andrew@xyncro.com"
    }
  ],
  "main": "spahql.js",
  "repository": {
    "type": "git",
    "url": "https://github.com/danski/SpahQL.git"
  },
  "keywords": [
    "json",
    "query",
    "ql",
    "language",
    "spah"
  ],
  "dependencies": {},
  "devDependencies": {
    "nodeunit": "*"
  },
  "license": "MIT",
  "engine": {
    "node": ">= 0.6.0 < 0.9.11-"
  },
  "readme": "#SpahQL: Query, manipulate and manage JSON data effortlessly.\n\n[github]: http://github.com/danski/spahql\n[js_minified]: https://raw.github.com/danski/spahql/master/spahql-min.js\n\n[spahql_getting_started]: #getting_started\n[selection_queries]: #selecting_data\n[modifying_data]: #modifying_data\n[spahql_listeners]: #listening_for_changes\n[assertion_queries]: #making_assertions\n[literals_and_sets]: #literals\n[comparison_operators]: #comparisons\n[object_equality]: #object_equality\n[strategies]: #spahql_strategies\n\n#Core concepts\n\nThink of SpahQL like jQuery, but instead of handling DOM elements, it handles JSON data. Instead of CSS selectors, you use SpahQL queries. It's a querying system for JSON data, aware of hashes, arrays, strings and booleans.\n\nYou can use SpahQL to fetch deeply-nested data, traverse large trees, and to query for data based on conditions, and to make assertions about data.\n\n#Install\n\nSpahQL has no dependencies - all you need is SpahQL itself.\n\n##Browser-based apps\n\nDownload the [latest minified JS][js_minified] and include it in your project.\n\n\t<script type=\"text/javascript\" src=\"path/to/spahql-min.js\"></script>\n\n##Node.js / CommonJS apps\n\nSpahQL is available through NPM, so installation is painless.\n\n\tnpm install spahql\n\nOnce installed, require it like any other CommonJS dependency.\n\n\tvar spahql = require('spahql');\n\n#Getting started\n\nUsing SpahQL starts out with you putting your data into a *SpahQL Database*. A *database* isn't a special object - it's just a regular SpahQL object holding the root data.\n\nLet's start out with an example - the state for a basic Twitter app UI.\n\n\tvar data = {\n\t  \"user\": {\n\t  \"logged_in\": true,\n\t    \"name\": \"John Doe\",\n\t    \"handle\": \"johndoe\",\n\t\t\t    \"avatar\": {\n\t\t\t\t\t\t\"small\": \"https://myapp.com/avatar-small/johndoe.png\",\n\t\t\t\t\t\t\"large\": \"https://myapp.com/avatar-large/johndoe.png\"\n\t\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\"draft_status\": \"The meaning of life is\",\n\t\t\"active_tab\": \"timeline\",\n\t\t\"timeline\": [\n\t\t\t{\n\t\t\t\t\"type\": \"status\",\n\t\t\t\t\"status\": \"FFFFFFFUUUUUUUUUUUU\",\n\t\t\t\t\"user\": {\n\t\t\t\t\t\"name\": \"Rage Guy\",\n\t\t\t\t\t\"handle\": \"rageguy\",\n\t\t\t\t\t\"avatar\": {\n\t\t\t\t\t\t\"small\": \"https://myapp.com/avatar-small/f7u12.png\",\n\t\t\t\t\t\t\"large\": \"https://myapp.com/avatar-large/f7u12.png\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\t...\n\t\t],\n\t\t\"mentions\": null\n\t\t\"direct_messages\": null\n\t}\n\nIn this state we've got the user's profile available to us for display, we know that the \"timeline\" tab is open and populated with some tweets, and we know that the user hasn't loaded any mentions or direct messages just yet. We also know that the user has typed something into the status field but has not yet saved it. We'll be using this example data below to explore SpahQL's capabilities.\n\nTo start using this data with SpahQL, we need to put it in a _SpahQL database_:\n\n\tvar db = SpahQL.db(data);\n\n#Selecting data\n\nNow that we've got a _SpahQL Database_ assigned to the <code>db</code> variable, we can start to pull data from it using SpahQL _selection queries_. We call the <code>db</code> object the _root_.\n\nThe query syntax is a little like XPath. Every item in your database can be considered to have a unique *path*, and you can query for that path specifically, or perform more advanced actions such as recursion and filtering.\n\nTo select items from the database, use the <code>select</code> method. This will return a new SpahQL object containing your results.\n\n    var user = db.select(\"/user\");\n    user.length; //-> 1\n    user.value(); //-> {\"logged_in\": true, \"name\": \"John Doe\", \"handle\": \"johndoe\" ... }\n\nIn the above example, we queried for the path <code>/user</code> which pulled the key \"user\" from the data. We can also chain keys together:\n\n\tvar avatar_large = db.select(\"/user/avatar/large\");\n\tavatar_large.value(); //-> \"https://myapp.com/avatar-large/johndoe.png\"\n\nThe <code>select</code> method returns a SpahQL object, so we can scope queries to results we already have:\n\n\tvar avatars = db.select(\"/user/avatar\");\n\tvar avatar_large = avatars.select(\"/large\")\n\tavatar_large.value(); //-> \"https://myapp.com/avatar-large/johndoe.png\"\n\nMuch like XPath, SpahQL supports recursion with a double-slash anywhere in the path. To find all avatars, no matter where they appear in the state, we'd do this:\n\n\tvar all_avatars = db.select(\"//avatar\");\n\nThis will return a set containing multiple results from several places in the original <code>db</code> object:\n\n\tall_avatars.length; //-> 2\n\tall_avatars.paths(); //-> [\"/user/avatar\", \"/timeline/0/user/avatar\"]\n\tall_avatars.values(); //-> [\"https://myapp.com/avatar-large/johndoe.png\", \"https://myapp.com/avatar-large/f7u12.png\"]\n\nNotice that the second path returned by <code>all_avatars.paths()</code> starts with <code>/timeline/0</code>. The key <code>0</code> refers to the first item an array, and this is how SpahQL handles arrays in general.\n\n\tvar second_tweet_in_timeline = db.select(\"/timeline/1\");\n\nThe <code>*</code> (asterisk) character works as a wildcard in paths, allowing you to pull every value from an object without recursion. To grab all tweets from the timeline:\n\n\tvar timeline_tweets = db.select(\"/timeline/*\")\n\ttimeline_tweets.paths(); //-> [\"/timeline/0\", \"/timeline/1\", \"/timeline/2\", ...]\n\nWe can also _filter_ the results at any point in the query. Here's an example where we filter the timeline for all tweets from a given user, and take the actual text of each tweet as the value:\n\n\tvar tweets_from_bob = db.select(\"/timeline/*[/user/handle == 'bob']/status\");\n\nIn the above, we took all objects from the timeline (<code>/timeline/*</code>) and filtered the list with an assertion (<code>[/user/handle == 'bob']</code>) - then we picked the tweet text from the remaining items (<code>/status</code>).\n\nNote that the contents of the filter were scoped to the object being filtered. This is fine for basic cases, but what if you need to compare the handle of each user to something else stored in the database?\n\nLet's add a field to the root object, for handling searches:\n\n\tdb.set(\"show_only_from_handle\", \"coolguy99\");\n\tdb.select(\"/show_only_from_handle\").value(); //-> \"coolguy99\"\n\nNow to filter the tweets based on this new bit of data, we can use the <code>$</code> (dollar sign) to scope any part of a filter to the root data:\n\n\tvar tweets_filtered = db.select(\"/timeline/*[/user/handle == $/show_only_from_handle]/status\");\n\nAnd voila, we've filtered one part of the state based on the contents of another, and selected some data from within.\n\nFilters may be chained together to produce logical <code>AND</code> gates. Here we'll pull all users who have both a large and a small avatar available:\n\n\tvar users_with_both_avatars = db.select(\"//user[/avatar/small][/avatar/large]\");\n\n#Working with results\n\n\n\n#Modifying data\n\nSpahQL objects provide a set of methods for modifying their data values. SpahQL always maintains _strict pointer equality_ to the original database data, so be aware that calling these methods will result in alterations being made directly to the object you originally passed to <code>SpahQL.db(your_data)</code>.\n\nMost destructive methods apply only to the first item in a SpahQL result set, and have a partner method which applies to the entire set. \n\nFor instance, here are the <code>replace</code> and <code>replaceAll</code> methods - just two of the many methods SpahQL offers for easy data editing:\n\n\tdb.select(\"//user\").replace(\"This string will replace the first user in the set\");\n\tdb.select(\"//user\").replaceAll(\"NO USERS FOR YOU\");\n\n#Listening for changes\n\nSpahQL objects are able to dispatch events when certain paths are changed, using an event-bubbling model similar to the HTML DOM.\n\n\tdb.listen(function(db, path, subpaths) {\n\t\tconsole.log(\"Something in the DB was modified. Modified paths: \"+subpaths.join(\",\"));\n\t})\n\nThe above code listens for changes to the database as a whole. You may scope listeners to certain paths using either of the following methods:\n\n\tdb.listen(\"/user\", function(user, path, subpaths) {\n\t\tconsole.log(\"User was modified: \", user.value());\n\t})\n\tdb.select(\"/user\").listen(function(user, path, subpaths) {\n\t\tconsole.log(\"User was modified: \", user.value());\n\t});\n\nThe callback function always receives three arguments; <code>result</code>, a SpahQL object containing the data found at the path on which you registered the listener, <code>path</code>, the path on which you registered the listener (allowing you to assign a single listener function cabable of responding to multiple changes), and <code>subpaths</code>, an array of paths within the <code>path</code> that were detected as having been modified.\n\n\tdb.listen(\"/user\", function(user, path, subpaths) {\n\t\tconsole.log(\"Subpaths modified on user (\"+path+\"): \", subpaths.join(\",\"));\n\t});\n\tdb.select(\"/user\").set({handle: \"modified-handle\", newobject: {foo: \"bar\"}});\n\t// -> prints the following to console:\n\t// Subpaths modified on user (/user): /handle,/newobject,/newobject/foo\n\n#Properties\n\nProperties are like imaginary paths on objects in your database. They allow you to make more interesting assertions about your data. Each property uses the <code>.propertyName</code> syntax and may be used in any path query:\n\nUse <code>.type</code> When you need to know what type of data is at any given path. Returns the object type as 'object', 'array', 'string', 'number', 'boolean' or 'null':\n\n\tresults = db.select(\"/timeline/.type\");\n\tresults.value() //-> 'Array'\n\nThe type property lets you query for all paths matching more precise criteria:\n\n\t// Find all arrays everywhere. \n\tvar all_arrays = db.select(\"//[/.type == 'array']\")\n        \nUse <code>.size</code> when you need to know about the amount of data in an object. Returns the object's size if it is a String (number of characters), Array (number of items) or Object (number of keys):\n        \n\tvar timeline_is_empty = db.assert(\"/timeline/.size < 1\"); //-> false, timeline contains items\n        \nUse <code>.explode</code> when you need to break an object down into components. Returns the object broken into a set that may be compared to other sets. Strings are exploded into a set of characters. Arrays and objects do not support this property - use the wildcard <code>*</code> character instead.\n\n\t// Does the user's handle contain a, b and c?\n\tresults = db.assert(\"/user/handle/.explode }>{ {'a','b','c'}\")\n\n#Making assertions\n\nWe've already seen how assertion queries can be used as filters in [selection queries][selection_queries]. Assertions can also be used on their own using SpahQL's <code>assert</code> method.\n\nSince the entity on either side of the comparison operator could contain one or more results (or no results at all), all comparisons in SpahQL are _set_ comparisons.\n\nAssertions are run through the <code>assert</code> method on the state:\n\n\tresult = db.assert(myQuery) //-> true or false.\n\nAssertions don't have to use comparisons:\n\n\tdb.assert(\"/user\"); //-> true, since /user exists and has a truthy value\n\tdb.assert(\"/flibbertygibbet\"); //-> false, since /flibbertygibbet doesn't exist, or is false or null\n\nMuch like selections, assertions can be scoped to a set of results you already have available:\n\n\tdb.select(\"/user\").assert(\"/handle\"); //-> true, since /user/handle exists\n\n#Comparisons\n\n\nSpahQL's set arithmetic uses the following operators for comparing values. To learn how values are compared, see [Object equality][object_equality].\n\n##Set equality <code>==</code>\n\nAsserts that both the left-hand and right-hand sets have a 1:1 relationship between their values. The values do not have to be in the same order. \n\n##Set inequality <code>!=</code>\n\nAsserts that the sets are not identical under the rules of the <code>==</code> operator.\n  \n##Subset of <code>}&lt;{</code>\n  \nAsserts that the left-hand set is a subset of the right-hand set. All values present in the left-hand set must have a matching counterpart in the right-hand set.\n  \n##Superset of <code>}&gt;{</code>\n\nAsserts that the left-hand set is a superset of the right-hand set. All values present in the right-hand set must have a matching counterpart in the left-hand set.\n\n##Joint set <code>}~{</code>\n\nAsserts that the left-hand set contains one or more values that are also present in the right-hand set.\n\n##Disjoint set <code>}!{</code>\n\n  Asserts that the left-hand set contains no values that are also present in the right-hand set.\n\n##Rough equality <code>=~</code>\n\n  Asserts that one or more values from the left-hand set are *roughly equal* to one or more values from the right-hand set. See [Object equality][object_equality].\n\n##Greater than (or equal to) <code>&gt;=</code> and <code>&gt;</code>\n\n  Asserts that one or more values from the left-hand set is greater than (or equal to) one or more values from the right-hand set.\n\n##Less than (or equal to) <code>&lt;=</code> and <code>&lt;</code> \n\n  Asserts that one or more values from the left-hand set is less than (or equal to) one or more values from the right-hand set.\n\n\n#Literals\n\nSpahQL does support literals - strings, integers, floats, <code>true</code>, <code>false</code> and <code>null</code> may all be used directly in SpahQL queries. Strings may use single or double quotes as you prefer.\n\nBecause all SpahQL comparisons compare sets to one another, all literals count as sets containing just one value. \n\nAs such, the following basic comparisons work just as you'd expect:\n\n\tdb.assert(\"/user/handle == 'johndoe'\") //-> true\n\tdb.assert(\"//user/handle == 'johndoe'\") //-> false. The left-hand set contains more than one item.\n\nYou may use set literals in SpahQL assertions. \n\nA set literal is wrapped in <code>{}</code> mustaches:\n\n\tdb.assert(\"//user/handle }~{ {'johndoe', 'anotherguy'}\") //-> true. The left set is a joint set with the right.\n\nSet literals may combine numbers, strings, booleans and even selection queries:\n\t\n\t// a set containing all the handles, plus one arbitrary one.\n\t{\"arbitrary_handle\", //user/handle} \n\nSets may not be nested - in the above example, SpahQL flattens the set literal to contain all the results of querying for <code>//user/handle</code> and one other value, <code>\"arbitrary_handle\"</code>.\n  \nRanges are also supported in set literals:\n\n    {\"a\"..\"c\"} // a set containing \"a\", \"b\" and \"c\"\n    {\"A\"..\"Z\"} // a set containing all uppercase letters\n    {\"Aa\"..\"Ac\"} // a set containing \"Aa\", \"Ab\", \"Ac\"\n    {0..3} // a set containing 0, 1, 2 and 3.\n    {\"a\"..9} // COMPILER ERROR - ranges must be composed of objects of the same type.\n    {\"a\"../foo/bar} // COMPILE ERROR - ranges do not support path lookup.\n\n#Object equality\n\nThere are two kinds of equality in SpahQL. *Strict* equality is applied with the <code>==</code> and other major operators, while *rough* equality is applied when using some of the more lenient operators such as <code>=~</code>.\n\n##Strict equality\n\nThe equality of objects is calculated based on their type. Firstly, for two objects to be equal under strict equality (<code>==</code>) they must have the same base type.\n\n###Object equality\n\nThe objects being compared must contain the same set of keys, and the value of each key must be the same in each object. If the value is an object or an array, it will be evaluated recursively.\n\n###Array equality\n\nThe arrays must each contain the same values in the same order. If any value is an array or object, it will be evaluated recursively.\n\n###Number, String, Bool, null\n\nThe objects must be of equal type and value.\n\n##Rough equality\n\nUnder rough equality (<code>=~</code>) the rules are altered:\n\n###Rough String equality\n\nStrings are evaluated to determine if the left-hand value matches the right-hand value, evaluating the right-hand value as a regular expression e.g. <code>\"bar\" =~ \"^b\"</code> returns <code>true</code> but <code>\"bar\" =~ \"^a\"</code> returns <code>false</code>\n\n###Rough Number equality\n\nNumbers are evaluated with integer accuracy only (using Math.floor, numeric.floor or an equivalent operation)\n\n###Rough Array equality\n\nArrays behave as if compared with the joint set operator.\n\n###Rough Object equality\n\nObjects are roughly equal if both hashes contain one or more keys with the same corresponding values. Values are compared using strict equality.\n\n###Rough Boolean and Null equality\n\nBooleans and Null objects are evaluated based on truthiness rather than exact equality. <code>false =~ null</code> is <code>true</code> but <code>true =~ false</code> is <code>false</code>.\n\nWhen using inequality operators <code>&lt;</code>, <code>=&lt;</code>, <code>&gt;</code>, <code>&gt;=</code>:\n\n* **Strings** are evaluated based on alphanumeric sorting. <code>\"a\" &lt;= \"b\"</code> returns <code>true</code> but <code>\"z\" &gt;= \"a\"</code> returns <code>false</code>.\n* **Numbers** are evaluated, as you'd expect, based on their native values.\n* **Arrays, Objects, Booleans, null** are not compatible with these operators and will automatically result in <code>false</code> being returned.\n\n#SpahQL Strategies\n\n_Strategies_ are a mechanism provided by SpahQL allowing you to define a queue of asynchronous actions to be run in order against a SpahQL object, provided that the value of the query result matches the criteria you specify. Pattern-wise, they're somewhere between a macro and a stored procedure. Strategies are managed using the <code>Strategiser</code> class.\n\n\t\tvar state = SpahQL.db({a: {aa: \"a.aa.val\", bb: \"a.bb.val\"}, b: {bb: \"b.bb.val\", cc: \"b.cc.val\"}});\n\t\tvar strategiser = new SpahQL.Strategiser();\n\nStrategies are objects which define a set of target paths, a condition which must be met for the strategy to run, and an action to take against the matched paths.\n\n\t\t// Add a strategy to the strategiser...\n\t\tstrategiser.addStrategy(\n\t\t\t// which will take action on /aa and /b/cc, but only if the assertion \"/b/bb\" returns true\n\t\t\t{\"paths\": [\"/aa\", \"/b/cc\"], \"if\": \"/b/bb\"}, \n\t\t\t// with a named category\n\t\t\t\"reduce\",\n\t\t\t// when triggered, the strategy will be called\n\t\t\tfunction(results, root, attachments, strategy) {\n\t\t\t\t\t// make changes to the matched results\n\t\t\t\t\tresults.deleteAll();\n\t\t\t\t\t// signal that the strategiser can advance to the next strategy in the queue\n\t\t\t\t\tstrategy.done();\n\t\t\t}\n\t\t);\n\nStrategies must specify the key _path_ or _paths_, a path or array of paths for the strategy to modify. Strategies may optionally use the key _if_ or _unless_, containing a SpahQL assertion whose expectation must be met for this strategy to be included. When we execute the strategies against a target SpahQL object, _path_, _paths_, _if_ and/or _unless_ will be evaluated relative to the target.\n\nStrategies also specify an _action_, a function containing the strategy's behaviour. It receives the arguments _results_, a SpahQL instance containing matches for the _path_, _root_, the original target SpahQL instance, _attachments_, an arbitrary object you may pass in when you execute the strategies, and _strategy_, an object containing flow control functions allowing you to signal that the strategy has completed.\n\nSpecifying multiple paths using the _paths_ key is equivalent to registering multiple strategies each with the same expectation and action - the action function will be called once for each query specified in the _paths_ array and calling <code>strategy.done()</code> will advance the queue to the next path in this strategy, or to the next strategy.\n\nExecution is as follows:\n\n\tstrategiser.run(target, category, attachments, callback);\n\nWhen applied to the above example:\n\n\t\t// Clone the State first to run the strategies without modifying the original\n\t\t// Run the strategies in the \"reduce\" category\n\t\t// Pass {foo: \"bar\"} as an attachment that will be available to all the strategies\n\t\t// Pass a callback function which will receive the modified SpahQL and the attachments\n\t\tstrategiser.run(state.clone(), \"reduce\", {foo: \"bar\"}, function(clone, attachments) {\n\t\t\t\tconsole.log(clone.select(\"/aa\").length()); //-> 0, as the above strategy deleted this value\n\t\t});",
  "readmeFilename": "readme.mdown",
  "_id": "spahql@0.7.6",
  "dist": {
    "shasum": "4496f0aa7547d150e6fd742059f0435a6fd11a6f",
    "tarball": "http://registry.npmjs.org/spahql/-/spahql-0.7.6.tgz"
  },
  "_from": "spahql@*",
  "_npmVersion": "1.2.12",
  "_npmUser": {
    "name": "danski",
    "email": "dan@angryamoeba.co.uk"
  },
  "maintainers": [
    {
      "name": "danski",
      "email": "dan@angryamoeba.co.uk"
    }
  ],
  "directories": {},
  "_shasum": "4496f0aa7547d150e6fd742059f0435a6fd11a6f",
  "_resolved": "https://registry.npmjs.org/spahql/-/spahql-0.7.6.tgz"
}
